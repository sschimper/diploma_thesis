\chapter{A brief introduction to ART}
The Advanced Rendering Toolkit (ART), serves as the environment in which Embree shall be integrated into. Therefore, this chapter provides a brief introduction to ART to familiarize the reader on its core mechanics. Apart from a short description of the general workflow of ART, only its aspects that are relevant for the integration of Embree are considered here. For a more detailed description of ART and the scene description language, we would like to refer the reader to the ART Handbook \cite{arthandbook} and the ARM File Reference Manual \cite{artreferencemanual}.\footnote{It should be mentioned here that at the time of writing this thesis, both documents are work in progress, which are not yet fully completed yet. They will be hopefully expanded in the future.}

The latest version of ART at the time of writing this thesis is Version 2.0.3.


\section{Purpose and features}

As indicated in the introduction, ART considers its target audience computer graphics researchers who are interested in the flied of predictive rendering. Predictive rendering is a branch of the computer graphics field that is dedicated to the research of light transport simulation, with which one can accurately predict the appearance of tan object or a virtual scene under different viewing conditions (compare \cite{wilkie2009predictive}.) \todo{use Alban's example} While the purpose of "conventional rendering" (to which we count the rendering procedures encountered in Chapter \ref{chap:fundamentals}) lies in the creation of "believable" imagery to create a certain impression to an observer, predictive rendering is concerned with the synthesis of radiometrically correct images, which serve as matters of conducting actual \todo{too informal?} research.

ART offers a variety of important features for predictive rendering that are currently non-standard in other "mainstream" rendering systems, such as polarization visualization support, the physically plausible handling of fluorescent materials \cite{mojzik2018handling}, and the enabling of spectral rendering. For the later, ART implements the "Hero wavelength spectral sampling" technique \cite{wilkie2014hero} and utilizes its own spectral image file format. Additionally, various research projects belonging to the "Sky Dome Appearance Project" are implemented in ART \cite{hosek2012analytic, hovsek2013adding, wilkie2013predicting}.


\section{Technical details}
ART	is composed of a number of UNIX-like-command line applications (therefore the name Advanced Rendering \emph{Toolkit}). The applications are written in \texttt{C} and \texttt{Objective-C}. 

In the following, we provide an overview over the individual applications contained in the toolkit:
\begin{description}
	% \setlength\itemsep{0.05em}
	\item[\emph{artist}] \hfil \\ This is the actual command-line application renderer, taking an ARM scene file as input and storing the raw information \todo{change} gathered by this process in an intermediate file with an proprietary file format.
	\item[\emph{tonemap}] \hfil \\ With this tool can be used for tone-mapping the (possibly spectral) information stored in the file, created by \texttt{artist} in order to obtain viewable results.
	\item[\emph{bugblatter}] \hfil \\ This application creates difference images of two provided, same-sized images, which can be crucial when debugging computer graphics applications.
	\item[\emph{polvis}] \hfil \\ Since ART supports rendering polarization effects by storing the amount of polarized light per pixel in each pixel of a spectral image, these polarization effects can be visualized by the use of this tool.
	\item[\emph{impresario}] \hfil \\ With this application it is possible to store and display intermediate rendering results from currently running rendering jobs \todo{"launch like a demon"}.
\end{description}

For our integration of Embree, the only relevant application is \texttt{artist}. 

\todo{explain ARM scene files}
In order to successfully render an image with \texttt{artist}, in the ARM scene file, one has to at least provide a virtual camera, scene geometry, and an action sequence. An action sequence is a user defined procedure, telling ART how to render the provided scene. Functionality of other applications like \texttt{tonemap} or \texttt{polvis} \todo{verify!} can be included in an action sequence.
In order to execute the individual steps  defined by an action sequence (which are referred to as \emph{actions}), ART makes use of a single stack data structure. During the execution of one such action, one or multiple data objects are taken off the stack, manipulated according to the action in question, and placed back on the stack. One example of such an action would be the creation of axis aligned bounding boxes for each object present in the scene. Here, the scene graph object is popped from the stack, bounding boxed are calculated for each geometry, then these boxes are inserted into the scene graph and more bounding boxes enclosing these for the geometries are calculated and inserted into the scene graph. Finally, the manipulated scene graph is pushed back to the stack.

Another noteworthy detail to mention is the ability of ART to utilize multiple available processor cores to perform a rendering job. \emph{emphasize multi-threading} By default, ART determines the number of available cores before the path tracing, but a number of a desired amount of cores can be provided as an application argument by the user. \todo{rephrase}
To achieve lock free parallelism between the individual threads, the scene graph is copied and one such copy is assigned to each thread. 
 

\section{Scene graph infrastructure}
Some popular rendering systems (among them Mitsuba 2 and pbrt) describe a virtual scene in the following way: A virtual scene, described by a \texttt{Scene} object, obtains a collection of geometric shapes. These shapes are represented by a \texttt{Shape} base class, which offers functions for calculating its bounding box and performing intersection tests with a given ray. Various shape types can be represented as a child class of this \texttt{Shape} class. This is an ideal design for Embree since these shapes can be initialized as User Defined Geometries. Once Embree finds an intersection with a bounding box of a particular shape, its representation in memory can be retrieved via the User pointer \todo{explain} and an instance function for ray-intersection testing can be called. 
The scene graph being utilized by ART diverges from this design. This section provides an overview over different nodes in the scene graph and their functionality on the basis of a provided example scene graph. This scene graph, which was used by ART to render the image displayed in Figure \ref{fig:csg_or}, is shown in Figure \ref{fig:scene_graph}. Table \ref{tab:scenegraph} will display nodes and a brief description of their functionality and relation to other nodes. However, we will only list nodes for which the comprehension of their functionality is important to follow the implementation description in the next chapter.
On particularity of the scene graph is that it can be utilized by every application mentioned in the previous section, with the exception of \texttt{impresario}. \todo{verify}. 


\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{img/2 art/scene_graph.png}
	\caption{Scene graph used to render Figure \ref{fig:csg_or}. In this graph, bounding boxes have already been inserted and a KD tree was built over the scene.} 
	\label{fig:scene_graph}
\end{figure}

\comment{
\begin{table}
	\centering
	{%\footnotesize\sf
		\begin{tabular}{llrl}
			\toprule
			Scene graph node & Role  \\
			\midrule
			\includegraphics{img/2 art/shape_node.png} & QWERTY- \\
			\includegraphics{img/2 art/comb_attr_node.png} & \textcolor{red}{BAD} \\
			\includegraphics{img/2 art/box_node.png} & Bounding box, enclosing the components of its sub tree. \\
			\includegraphics{img/2 art/csg_node.png} & Nodes with two children, representing the primitives to which this CSG operation is applied to (in this example, it the two nodes are representing the union operation). \\
			\includegraphics{img/2 art/bsp_node.png} & Represents the KD tree that is build over the scene. Its children are the entire scene geometry, a  \\
			% \addlinespace % a nice non-intrusive separator of data groups (or final table sums)
			\bottomrule
	\end{tabular}}
	\caption{Nodes in the scene graph and their functionality}
	\label{tab:z}
\end{table}
} % comment

\section{The Raycaster object}
\todo{don't spend too much time on this}

\section{Other information (WT)}