% !TeX spellcheck = en_US
\chapter{Our approach on the integration of Embree into ART}
\label{chap:math}

This section outlines our approach of the integration of Embree into ART. The language, in which the individual procedures \todo{wrong word} are formulated is Objective-C, since the higher level functionality of ART has been written in this language, too. Embree itself is written in C and intended for the adaption to image synthesis environments being written in C/C++. However, due to Objective-C being a strict superset of C, these two languages can be intermixed seamlessly. Therefore, no issues concerning the cross-linking of C and Objective-C were discovered during the development.

\section{Design choices}

One important design choice was to abstract functionality regarding Embree inside a single class, which we gave the name \texttt{ArnEmbree}, conform to the naming convention of Objective-C classes in ART. Classes of type "\texttt{Arn<name>}" belong to the category of so-called "Scene graph classes", to which, according to our own opinion, the functionality regarding Embree belongs the closest to. To the tasks of this class belong the creation and deletion of an Embree scene, the adding of different scene geometry, and performing the intersection calculations with Embree. This class should act as a singleton object. To quote from ART's user manual \cite[Chapter 4.1.2]{arthandbook} "Apart from this struct, [the \texttt{art\_gv} global variable] there are no genuine global variables in ART, only global constants". The singleton object obviously contradicts this statement. The main reason for this design is to keep the functionality regarding Embree separate form the functionality of what we will from now on refer to as \emph{native ART}, the original ART without Embree integration. At the beginning of this project, it was not clear whether both the research question of this thesis ("Can the CSG operations of ART be implemented using Embree?") and the question of whether Embree could be integrated into ART at all could be positively answered. In case of our work being unsuccessful, this separation would ease the process of reverse engineering ART to its initial state.
In spite of this separation, an inclusion of the \texttt{ArnEmbree} singleton to the \texttt{art\_gv} variable should is possible and not too difficult.

Another design decision was to enable support of Embree only when the user of ART provided a parameter flag \texttt{-e} or \texttt{--embree} when invoking \texttt{artist}, like so:

\begin{Verbatim}
$ artist foo_scene.arm -e
\end{Verbatim}

Initilally, the provision of a parameter flag was intended to easily switch Embree support on and off in order to draw comparisons between the performances. However, this turns out to be still valuable, because certain scenes will be rendered faster with Embree and some will not. We will turn to this circumstance in more depth when discussing the results in Chapter \ref{chap:results}. 

When the command line arguments of \texttt{artist} are evaluated, the \texttt{ArnEmbree} singleton class object, which we call "\texttt{embreeManager}", is initialized and set up, if the parameter flag was provided. Otherwise, the object is set to \texttt{NULL}. From this point on, the \text{ArnEmbree} singleton can be retireved anywhere in the code and at any point of the action sequence by the instruction, shown in Listing \ref{lst:embree_manager}.

\begin{listing} 
	\begin{lstlisting}
	ArnEmbree * embree = [ArnEmbree embreeManager];
	\end{lstlisting}
	\caption{Retrieving the \texttt{ArnEmbree} singleton.}
	\label{lst:embree_manager}
\end{listing}


\begin{listing}
	\begin{lstlisting}
	 if( [ArnEmbree embreeEnabled] ) 
	 {
	 		// ...
	 }
	\end{lstlisting}
	\caption{Verifying if the \texttt{ArnEmbree} singleton was initialized.}
	\label{lst:check_embree}
\end{listing}

Furthermore, if the singleton was initialized and set up, another global boolean variable is set to true. The value of this boolean can be retrieved by calling a class method called \texttt{embreeEnabled}. An example of this is given in Listing \ref{lst:check_embree}.

\section{The \texttt{ArnEmbree} singleton class and the extension of the \texttt{RayCaster} object}

The \texttt{ArnEmbree}, which is inherited from the \texttt{ArcObject} base class in ART, is initially constructed the following way: Instance variables are provided to store a single \texttt{RTCDevice} and a single \texttt{RTCScene} object for Embree. Although the instantiation of multiple RTCScenes on a single RTCDevice is possible with Embree, we are considering only single scenes containing all scene geometry. Furthermore, in this class, methods are defined for adding initializing different geometry types for Embree, adding them to the RTCScene, and finally commiting the RTCScene, which will trigger the build of Embree's own spatial acceleration data structures. \todo{what about committing scenes}
In order to perform the actual ray-intersection testing with Embree, a class method was added to the \texttt{RayCaster} class, which is called \texttt{getIntersectionListWithEmbree}. In case Embree support is enabled, this method is called, rather than traversing ART's KD tree natively. In this function, a given ray is converted to an \texttt{RTCRay} and Embree's native function for intersection testing, \texttt{rtcIntersect1()}, is called. Since ART only support the cast of single rays, as opposed to ray packet, functionality for casting ray packets with Embree is not considered. After the intersection testing is performed, depending whether if an intersection is found, the received \texttt{tfar}, the uv coordinates, surface normal, and shape associated with the hit are stored in a \text{ArIntersectionList} data structure \todo{explain} and the path tracing procedure precedes as usual.

\section{Initializing shapes for Embree}

ART supports a variety of different geometrical shapes. An overview of these shapes can be found in the "ARM File Reference Manual" \cite{artreferencemanual}. The shapes are divided by ART into two categories: \emph{Analytic shapes} and \emph{Simple indexed shapes}. Analytic shapes in ART are represented as outline in Section \ref{sec:quadrics} in Chapter \ref{chap:fundamentals}. Simple indexed shapes on the other side are described by an array of vertices (3D points) associated with it and an array of indices for the avoidance of storing a vertex multiple times in memory \todo{rephrase}. To be precise, two shapes, namely triangles and quadrangles are considered simple indexed shapes in ART. Figure \ref{fig:shape_types} gives an overview over the categories of shapes in ART. This section describes the initialization of these shape types for Embree. For now, we will not consider the initialization of CSG geometry (see Figure \ref{fig:art_csg}), since an own section is dedicated to the description of this.

\begin{figure}[!tbp]
	\centering
	\subfloat[Simple indexed shape: Triangle.]{\includegraphics[width=.3\textwidth]{img/3 approach/triangle.png}\label{fig:art_triangle}}
	\hfill
	\subfloat[Analytical shape: Torus aligned on Y-axis.]{\includegraphics[width=.3\textwidth]{img/3 approach/torus.png}\label{fig:art_torus}}
	\hfill
	\subfloat[CSG geometry: Grooved sphere.]{\includegraphics[width=.3\textwidth]{img/3 approach/csg_shape.png}\label{fig:art_csg}}
	\caption{Types of shapes in ART.}
	\label{fig:shape_types}
\end{figure}

Although it would be convenient to describe analytic shapes and simple indexed shapes as User defined geometry, we make the distinction between \emph{User defined geometry} and \emph{Non-user defined geometry}. Into the first category will fall the analytically described shapes, while triangles and quadrangles will be represented by Embree's own primitive types \texttt{RTC\_GEOMETRY\_TYPE\_TRIANGLE} and \texttt{RTC\_GEOMETRY\_TYPE\_QUAD}. This division makes sense, since the rendering of these primitive types with Embree is more efficient than User defined geometries. Furthermore, all the information needed to set up these primitive types are the vertices and indices associated with the primitive. They can be easily transferred from ART to Embree. 

The initialization geometries for Embree takes place during the assembly of the scene graph from the information that have been parsed from the ARM scene file. At the step \todo{reformulate}, when the "Combined Attributes"- and "Shape"-node associated with the geometry are created and inserted to the graph as leafs, a class method of \texttt{ArnEmbree}, \text{initEmbreeGeometry()}, is called, and the shape itself together with the shape object, the newly created "Combined Attributes" node, the traversal state \todo{explain} of the RayCaster, the vertex set object containing the vertices of the shape, and finally, the transformation matrix. In this function, a new \texttt{RTCGeometry} is being initialized and set up according to the category of the shape in question. This variable has the name "newGeometry". Different class methods are dedicated to this task. After the individual set up, we are committing the geometry, attaching it to Embree, and releasing it. When a geometry is successfully attached for Embree, a unique identifier is assigned to it. This identifier, and unsigned integer value, is refereed to as the \emph{Geometry ID}. We store this Geometry ID in an instance variable of the "Shape" and "Simple Indexed Shape" classes. This identifier allows us, to retrieve the RTCGeometry from Embree and to perform alterations on it. However, the retrieving of RTCGeometry is only possible before the RTCScene is committed. \footnote{We are not making use of this feature in this thesis, however, it may be useful to have for future work.}

\begin{listing} 
	\begin{lstlisting}
	// each geometry in the scene is associated with
	// one of this stuct, it is needed for embree to
	// perform user defined geometry intersection
	// calculations
	typedef struct GeometryData {
		unsigned int _embreeGeomID; // geometry id of the shape
		ArNode * _shape; // ART's shape representation in memory
		ArTraversalState _traversalState; // state of the RayCaster
		
		// the following are explained in the ray casting chapter
		ArNode<ArpRayCasting> * _combinedAttributes_or_csg_node;
		BOOL _isUserGeometry; 
		BOOL _isCSGGeometry;
	}
	GeometryData;
	\end{lstlisting}
	\caption{\text{C} struct associated with each initialized geometry.}
	\label{lst:user_data}
\end{listing}

Once a geometry is attached to Embree, a \text{C} struct associated to the geometry in question is dynamically allocated ans stored in a linked list, whose head is an instance variable of the \texttt{ArnEmbree} class. Associated with it are the geometry id, ART's shape representation in memory, the traversal state of the \texttt{RayCaster} object, a node, which can either be a "Combined Attributes" node, or a "CSG node" which are used for the performing of ray tracing and two boolean variables indicating what category the geometry falls into. The last three variables will be discussed in more detail in Subsection \ref{sec:embree_raycasting}.


\subsection{Triangles, quadrangles, and triangle meshes}
Simple index geometry are initialized the following way: Inside the \text{initEmbreeGeometry()} function, another class method with the name \texttt{initEmbreeSimpleIndexedGeometry()} is called, with the shape object the vertex set, and the transformation matrix being passed as arguments. 

\begin{listing} 
	\begin{lstlisting}
	RTCGeometry newGeometry = NULL;
	float * vertices;
	unsigned * indices;
	
	// if the shape is a triangle, 
	// create a new geometry buffer with type
	// RTC_GEOMETRY_TYPE_TRIANGLE
	if([shape isKindOfClass: [ArnTriangle class]]) 
	{
	
		newGeometry = rtcNewGeometry(device, RTC_GEOMETRY_TYPE_TRIANGLE);
		
		vertices = (float *) rtcSetNewGeometryBuffer(
													newGeometry,
													RTC_BUFFER_TYPE_VERTEX,
													0,
													RTC_FORMAT_FLOAT3,
													3*sizeof(float),
													3
													);
		
		indices = (unsigned *) rtcSetNewGeometryBuffer(
		                        newGeometry,
		                        RTC_BUFFER_TYPE_INDEX,
		                        0,
		                        RTC_FORMAT_UINT3,
		                        3*sizeof(unsigned),
		                        1
		                        );
	
	}
	\end{lstlisting}
	\caption{Setting up geometry buffers for the vertices and indices of a triangle shape.}
	\label{lst:geometry_buffer}
\end{listing}

In this function, depending of the geometry argument being of type "Triangle" or type "Quadrangle", a new RTCGeometry object is initialized either with geomtry type \texttt{RTC\_GEOMETRY\_TYPE\_TRIANGLE} or \texttt{RTC\_GEOMETRY\_TYPE\_QUAD}. This is followed by the creation and assignment of two geometry buffers, one for storing the vertices associated with the shape and one for storing its indices. Listing \ref{lst:geometry_buffer} shows how the function \text{rtcSetNewGeometryBuffer()} is used to achieve that for a triangle shape. As input parameters it takes the RTCGeometry to with the geometry buffer is associated with, the buffer type, a buffer slot number (here 0), the specified format for the buffer (RTC\_FORMAT\_FLOAT3 and RTC\_FORMAT\_UINT3 in the listing), a byte stride argument and the number of items stored in the buffer. 

The settup for the geometry buffers for quadrangle is almost identical, with the only exception being that the RTCGeometry is initialized with the geometry type \texttt{RTC\_GEOMETRY\_TYPE\_QUAD} and that the byte stride of the vertex buffer is four instead of three.

Once these buffers are initialized, the vertices stored in the vertex set and indices associated with the shape representation of ART are transfered to the vertex and index geometry buffers. In case the transformation matrix passed to the function is not \text{NULL}, the vertices, one py one, are multiplied with that transformation matrix before the transfer to the vertex buffer. Embree allows for instancing of geometry, meaning that geometry in Embree can be translated, scaled, and rotated by refering to an original instance stored in memory and applying the transformation to an instance of it. However, we decided to go with the transformation calculation for each vertex, because it is more intuitive and easier realised.
The initialization of a triangle mesh, beeing parsed from a PLY file with the help of the "RPly" library \cite{rply2016} follows the same outline described for triangles and quadrangles, although not falling into the category of simple indexed shapes. The only difference is that the number of items for Embree's vertex geometry buffer is set to the number of total faces of the mesh being associated with the mesh representation of ART.
At the end, the newly created RTCGeometry is returned from this function, and assigned to the RTCGeometry, created in the \text{initEmbreeGeometry()} function. After the sucessful initialization of these types of shapes, a \texttt{GeometryData} struct as shown in Listing \ref{lst:user_data} is allocated on the heap and the \text{isUserGeometry} boolean variable is set to false. In subsection \ref{sec:embree_raycasting} we will go into more detail about why this was engineered in this way.


\subsection{User defined geometry}
Under this category fall any shape of ART other than trianlges, quadrangles and triangle meshes. These shapes shall be initialized as User defined geometries. For initializing this kind of geometry type, one needs to provide three functions that are used by Embree as callback functions: one for calculating the bounding box of the shape, one for performing the actual ray-primitive instersection testing and one for testing for occlusion. For the setup of these shapes, an RTCGeometry with the type \texttt{RTC\_GEOMETRY\_TYPE\_USER} is initialized. This is followed by passing three plain \texttt{C} functions for calculating the bounding box, testing for intersection points and testing for occlusion. 
These functions have the name \texttt{embree\_bbox()}, \texttt{embree\_intersect()}, and \texttt{embree\_occluded()}. Generally speaking, only one function for inersection finding \todo{too informal} and occlusion testing would be necessary since both operation are performed by ray casting. However, Embree strictly expects two speperate function, each with a predetermined argument list. In order to compensate for this, we use a strategy which was inspired by the source code of Mitsuba 2 \cite{nimier2019mitsuba}\todo{do I need to cite this again?}: We refractor the ray tracing functionality into a fourth function called \texttt{embree\_intersect\_geometry()}, which is called from both the \texttt{embree\_intersect()} and \texttt{embree\_occluded()} function. 
In the interior of the function \texttt{embree\_bbox()}, the bounding box for a shape in question is calculated by function provided by the ART interface \todo{can I put it like that?} and passed to Embree. \texttt{embree\_bbox()} will be called by Embree, once the RTCScene is committed. Based on these bounding boxes, Embree will cunstruct its BVH. Once such an intersection with such a bounding box is found, Embree will call the \texttt{embree\_intersect()} function, in which the ray-primitive intersection testing is performed (the ART way\todo{definetely rephrase}) with the shape associated with that bounding box.


\todo{bullet lists}

\subsection{Ray tracing with Embree}
\label{sec:embree_raycasting}

Once the geometries contained in a virtual scene are initilialized for Embree, and Embree's internal BVH has been created, the scene is ready to be ray cast with Embree. Therefore, if Embree support is enabled by the user, a member function of the \texttt{RayCaster} class with the name \texttt{getIntersectionListWithEmbree()} is called, which takes an empty \text{ArIntersectionList} struct \todo{explain} as an argument. In the body of this function, an \texttt{RTCIntersectContext} \todo{explain} is set up and a \texttt{RTCRayHit}\todo{explain too!} struct is declared.
This is followed by the update of the \texttt{RTCRayHit}, which is a unification of an \texttt{RTCRay} and an \texttt{RTCHit} struct with the current state of the \texttt{RayCaster} object. The information of the \texttt{RayCaster} object that is being transfered to the \texttt{RTCRayHit} stuct contains the orientation and direction of the ray that is about to be cast into the scene, and the ID associated to the ray. The \texttt{tfar} value of is initialized with Objective-C's \texttt{INFINITY} macro and the \texttt{geomID} field of the \texttt{RTCHit} struct is initialized with the macro \texttt{RTC\_INVALID\_GEOMETRY\_ID}. As mentioned, \todo{mention this} Embree utilizes single precision floating point numbers for its internal calculations, whereas ART uses double precision floating point numbers. To compensate for visual artifacts in the final image, we do not intitialize the \texttt{tnear} value of the \texttt{RTCHit} with zero, we instead give it a little offset, to prevent intersection between a secondary ray and the same shape that was already hit. We found the value $1e-3f$ to be reliable. A comparision of an image, rendered with and without this offset is given by Figure \ref{fig:offset}.

\begin{figure}[!tbp]
	\centering
	\subfloat[Rendering a quad without offsetting the \texttt{tnear} value.]{\includegraphics[width=.4\textwidth]{img/3 approach/artifact_2.png}}
	\hfill
	\subfloat[Rendering a quad with offsetting the \texttt{tnear} value by $1e-3f$.]{\includegraphics[width=.4\textwidth]{img/3 approach/artifact.png}}
	\caption{Artifacts due to the conversion of the hit distance of the ray from a double precision floating point number to a single precision floating point number.}
	\label{fig:offset}
\end{figure}

After the update of the \texttt{RTCRayHit} struct, the actual ray tracing is performed by calling the \texttt{rtcIntersect1()} function. Depending on whether a bounding box of a User geometry or Non-User geometry was hit with the \texttt{RTCRay}, either the provided callback function for intersecting User defined geometries, \texttt{embree\_intersect\_geometry()} or Embree performs the intersection testing with its own functionality. \todo{rephrase}


\subsubsection{own intersect function}

\todo{inf sphere}


\section{Implementation of CSG operators to work with ART (WT)}
\subsection{Approach 1}
\subsection{Approach 2}
\subsection{Approach 3}
